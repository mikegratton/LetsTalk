<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Let&#39;s Talk: Let&#39;s Talk: A C++ Interprocess Communication System Based on FastDDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Let&#39;s Talk
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Simple DDS communication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Let's Talk: A C++ Interprocess Communication System Based on FastDDS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_mike_git_letstalk_README"></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Introduction</h1>
<p>Let's Talk is a C++ communication library compatible with DDS (the Data Distribution Service) designed for simple and efficient interprocess coordination on local networks. As DDS is the communication standard used by ROS2, it's compatible with ROS2. The library is an API wrapped around the FastDDS library, along with a distribution of that library and cmake tools for compiling/linking to DDS. It's guiding principle is that <em>simple things should be easy</em>. So it trys to adopt sensible defaults while providing access to more functionality through optional arguments.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Links</h1>
<ul>
<li><a href="https://github.com/mikegratton/LetsTalk">GitHub Repository</a></li>
<li><a href="https://mikegratton.github.io/LetsTalk/">Documentation</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Example</h1>
<p>Here's the basic "hello world" example from <a href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/getting_started/simple_app/simple_app.html">Fast DDS</a> using the Let's Talk API:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;LetsTalk.hpp&quot;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;HelloWorld.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(int, char**)</div>
<div class="line">{</div>
<div class="line">    auto node = lt::Participant::create();</div>
<div class="line">    node-&gt;subscribe&lt;HelloWorld&gt;(&quot;HelloWorldTopic&quot;, [](HelloWorld const&amp; data) {</div>
<div class="line">        std::cout &lt;&lt; data.message() &lt;&lt; &quot; &quot; &lt;&lt; data.index() &lt;&lt; std::endl;</div>
<div class="line">    }); </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::minutes(1));            </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;LetsTalk.hpp&quot;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;HelloWorld.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv)</div>
<div class="line">{</div>
<div class="line">    auto node = lt::Participant::create();</div>
<div class="line">    auto pub = node-&gt;advertise&lt;HelloWorld&gt;(&quot;HelloWorldTopic&quot;);</div>
<div class="line">    while(node-&gt;subscriberCount(&quot;HelloWorldTopic&quot;) == 0) {</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; &quot;Publication begins...\n&quot;;</div>
<div class="line">    for(int i=0; i&lt;100; i++) {</div>
<div class="line">        HelloWorld msg;</div>
<div class="line">        msg.message(&quot;Test&quot;);</div>
<div class="line">        msg.index(i);</div>
<div class="line">        bool okay = pub.publish(msg);</div>
<div class="line">        std::cout &lt;&lt; &quot;Sent &quot; &lt;&lt; i &lt;&lt; &quot;  &quot; &lt;&lt; (okay? &quot;okay&quot; : &quot;FAILED&quot;) &lt;&lt; std::endl;</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">        if (node-&gt;subscriberCount(&quot;HelloWorldTopic&quot;) == 0 || !okay) {</div>
<div class="line">            break;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> As you can see, subscription involves providing a callback function, typically a lambda. Publication uses a Publisher object.</p>
<p>The design of the main Participant API is largely based on the ignition::transport API, a very convenient ZMQ/protobuf communication system. Let's Talk is not ignition::transport compatible, however. Basic publish/subscribe should be compatible with other DDS vendors (RTI Connext, Cyclone, etc.), but DDS has long been infamous for poor compatibility between vendors, and Let's Talk doesn't try to solve that.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Installation</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
As a submodule</h2>
<p>The easiest way to use Let's Talk is as a git submodule. </p><div class="fragment"><div class="line">git submodule add -b &lt;desired version branch&gt; git@github.com:mikegratton/LetsTalk.git</div>
</div><!-- fragment --><p> In your CMakeLists.txt, add </p><div class="fragment"><div class="line">add_subdirectory(LetsTalk)</div>
</div><!-- fragment --><p> This will provide the following cmake targets:</p>
<ul>
<li>letstalk &ndash; The library (with appropriate includes)</li>
<li>fastrtps &ndash; The underlying FastDDS library</li>
</ul>
<p>To include and link <code>myTarget</code> to letstalk, you just need to add the CMake </p><div class="fragment"><div class="line">target_link_libraries(myTarget PUBLIC letstalk)</div>
</div><!-- fragment --><p> (Letstalk depends on fastrtps, but you don't need to reference it directly.)</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Via an installation</h2>
<p>If you have several projects that depend on Let's Talk, it is more efficient to install the library per usual. In this case, check out the code and do </p><div class="fragment"><div class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake .. -DCMAKE_INSTALL_PREFIX=&lt;your install dir&gt; -DCMAKE_BUILD_TYPE=Release &amp;&amp; make install</div>
</div><!-- fragment --><p> This will provide a cmake config script at <code>&lt;your install dir&gt;/lib/cmake/letstalk</code> that you can use in your cmake like </p><div class="fragment"><div class="line"> list(APPEND CMAKE_MODULE_PATH &lt;your install dir&gt;/lib/cmake/letstalk)</div>
<div class="line">list(APPEND CMAKE_PREFIX_PATH &lt;your install dir&gt;/lib/cmake/letstalk)</div>
<div class="line"> find_package(letstalk)</div>
</div><!-- fragment --><p> This will provide the same cmake targets (<code>letstalk</code> and <code>fastrtps</code>) for linking as above.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
IDL Support in CMake</h2>
<p>Working with IDL in Let's Talk is especially easy. Inspired by the protobuf CMake support, Let's Talk provides an "IdlTarget.cmake" macro. Basic operation is </p><div class="fragment"><div class="line">list(APPEND CMAKE_MODULE_PATH &lt;your install dir&gt;/lib/cmake/letstalk)</div>
<div class="line">include(IdlTarget)</div>
<div class="line">IdlTarget(myIdlTarget SOURCE MyIdl.idl MyOtherIdl.idl)</div>
<div class="line">...</div>
<div class="line">target_link_library(myTarget PUBLIC myIdlTarget)</div>
</div><!-- fragment --><p> That is, IdlTarget creates a cmake target consisting of a library built from the provided compiled IDLs, linking transitively to Fast CDR, and providing access to the header include path as a target property. The header and source files are stored in the build directory. If the IDL is changed, make/ninja will correctly re-run the IDL compiler, recompile the IDL target, and re-link. The intention is to have machine-generated code segregated from the rest of the codebase. More options for controlling the include path are documented in IdlTarget.cmake.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Communication Patterns</h1>
<p>Let's talk offers three communication patters:</p>
<ul>
<li>Publish/Subscribe: A loosely coupled pattern based on topic names. Publishers send data to all subscribers. Subscribers get data from all publishers. Let's Talk is capable of both reliable and best effort connections, but does not provide support for persistence between multiple runs of a program.</li>
<li>Request/Reply: Also known as remote proceedure call (RPC), each request will be served by a responder. Each service is identified by its service name, the request type, and the reply type. Let's Talk implementation is simple. If there are multiple providers for a service, an error is logged, but no attempt is made to determine which provider will handle a given call. Calls use the C++ promise/ future types, including setting exceptions on failure.</li>
<li>Reactor: A request/reply pattern where requests recieve multiple "progress" replies, before finally ending with a final reply. These are useful in robotics where calculations or actions take appreciable time during which the requesting process may need to cancel or retask the service provider as the situation changes.</li>
</ul>
<p>Below are some more details on each. See also the <code>examples</code> directory with sample code to crib from.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Publish/Subscribe</h2>
<p>In pub/sub, a group of publishers send data to all subscribers that match on a topic. Topics are strings (e.g. "robot.motion.command") but also have a defined type. To subscribe, you register a callback with a participant, </p><div class="fragment"><div class="line">lt::ParticipantPtr node = <a class="code" href="classlt_1_1Participant.html#a266f5f43e44e21fa68f9b7d83899c0e1">lt::Participant::create</a>();</div>
<div class="line">node-&gt;subscribe&lt;MyType&gt;(<span class="stringliteral">&quot;my.topic&quot;</span>, [](MyType <span class="keyword">const</span>&amp; sample) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Got some data!\n&quot;</span>;</div>
<div class="line">});</div>
<div class="ttc" id="aclasslt_1_1Participant_html_a266f5f43e44e21fa68f9b7d83899c0e1"><div class="ttname"><a href="classlt_1_1Participant.html#a266f5f43e44e21fa68f9b7d83899c0e1">lt::Participant::create</a></div><div class="ttdeci">static ParticipantPtr create(uint8_t i_domain=0, std::string const &amp;i_qosProfile=&quot;&quot;)</div><div class="ttdoc">Makes a new Participant. (There is no public constructor)</div><div class="ttdef"><b>Definition:</b> Participant.cpp:25</div></div>
</div><!-- fragment --><p> or, if you wish to get samples as unique_ptrs (because you plan to move them to another thread), </p><div class="fragment"><div class="line">node-&gt;subscribe&lt;MyType&gt;(<span class="stringliteral">&quot;my.topic&quot;</span>, [](std::unique_ptr&lt;MyType&gt; sample) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Got some data!\n&quot;</span>;</div>
<div class="line">});</div>
</div><!-- fragment --><p> <em>IMPORTANT:</em> This callback is run on a pub/sub thread, so long calculations or waits for a lock will negatively impact the whole system. A good practice is to simply enqueue the data on a thread-safe queue for later processing. Let's Talk provides such a queue as <code>ThreadSafeQueue</code>, and a convenience subscription mode, </p><div class="fragment"><div class="line">lt::QueuePtr&lt;MyType&gt; myTypeQueue = lt::node-&gt;subscribe&lt;MyType&gt;(<span class="stringliteral">&quot;my.topic&quot;</span>);</div>
</div><!-- fragment --><p> The queue then supplies <code>pop()</code> to get a sample (with an optional wait time) and <code>popAll()</code> to get all pending samples, </p><div class="fragment"><div class="line">std::unique_ptr&lt;T&gt; pop(std::chrono::nanoseconds i_wait = std::chrono::nanoseconds(0));</div>
<div class="line">Queue popAll(std::chrono::nanoseconds i_wait = std::chrono::nanoseconds(0));</div>
</div><!-- fragment --><p> where the <code>Queue</code> type is a <code>std::deque&lt;std::unique_ptr&lt;T&gt;&gt;</code> by default.</p>
<p>You can use the <code>QueueWaitset</code> to wait on multiple queues in a <code>select</code>-like manner. First, register all the queues with the waitset at construction: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> queue1 = node-&gt;subscribe&lt;MyType1&gt;(<span class="stringliteral">&quot;my.topic.1&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> queue2 = node-&gt;subscribe&lt;MyType2&gt;(<span class="stringliteral">&quot;my.topic.2&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> waitset = <a class="code" href="namespacelt.html#a5f18cbd891c604c0531c6c3a06e5c914">makeQueueWaitset</a>(queue1, queue2);</div>
<div class="ttc" id="anamespacelt_html_a5f18cbd891c604c0531c6c3a06e5c914"><div class="ttname"><a href="namespacelt.html#a5f18cbd891c604c0531c6c3a06e5c914">lt::makeQueueWaitset</a></div><div class="ttdeci">auto makeQueueWaitset(QueuePtr&lt; Ts &gt; &amp;... io_waitsets)</div><div class="ttdoc">Build a waitset out of one or more QueuePtr&lt;T&gt;'s.</div><div class="ttdef"><b>Definition:</b> QueueWaitset.hpp:133</div></div>
</div><!-- fragment --><p> Later, you may <code>wait</code> for data, blocking the calling thread and returning the index of the first queue with pending messages </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> triggerIndex = waitset.wait();</div>
<div class="line"><span class="keywordflow">switch</span> (triggerIndex) {</div>
<div class="line">    <span class="keywordflow">case</span> 0: {</div>
<div class="line">        <span class="keyword">auto</span> content = queue1-&gt;popAll();</div>
<div class="line">        <span class="keywordflow">if</span> (queue1.size() &gt; 0) {</div>
<div class="line">            <span class="comment">// Process the data                    </span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Note fallthrough</span></div>
<div class="line">    <span class="keywordflow">case</span> 1: {</div>
<div class="line">        <span class="keyword">auto</span> content = queue2-&gt;popAll();</div>
<div class="line">        <span class="keywordflow">if</span> (queue2.size() &gt; 0) {</div>
<div class="line">            <span class="comment">// Process the data</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> See <code>example/waitset</code></p>
<p>To cancel a subscription, the Participant provides an unsubscribe function, </p><div class="fragment"><div class="line">node-&gt;unsubscribe(<span class="stringliteral">&quot;my.topic&quot;</span>);</div>
</div><!-- fragment --><p> You can also query how many publishers have been discovered for the topic, </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> count = node-&gt;publisherCount(<span class="stringliteral">&quot;my.topic&quot;</span>);</div>
</div><!-- fragment --><p>On the publisher end, Participant acts as a factory for creating lightweight <code>Publisher</code> objects, </p><div class="fragment"><div class="line">lt::ParticipantPtr node = <a class="code" href="classlt_1_1Participant.html#a266f5f43e44e21fa68f9b7d83899c0e1">lt::Participant::create</a>();</div>
<div class="line"><a class="code" href="classlt_1_1Publisher.html">lt::Publisher</a> pub = node-&gt;advertise&lt;MyType&gt;(<span class="stringliteral">&quot;my.topic&quot;</span>);</div>
<div class="ttc" id="aclasslt_1_1Publisher_html"><div class="ttname"><a href="classlt_1_1Publisher.html">lt::Publisher</a></div><div class="ttdoc">Sends messages to a topic.</div><div class="ttdef"><b>Definition:</b> Participant.hpp:264</div></div>
</div><!-- fragment --><p> To use it, </p><div class="fragment"><div class="line">MyType sample;</div>
<div class="line"><span class="comment">/* ... fill out sample here */</span></div>
<div class="line">pub.<a class="code" href="classlt_1_1Publisher.html#aa9a5ba8316bc12616e663feef7531ad3">publish</a>(sample);</div>
<div class="ttc" id="aclasslt_1_1Publisher_html_aa9a5ba8316bc12616e663feef7531ad3"><div class="ttname"><a href="classlt_1_1Publisher.html#aa9a5ba8316bc12616e663feef7531ad3">lt::Publisher::publish</a></div><div class="ttdeci">bool publish(std::unique_ptr&lt; T &gt; i_data)</div><div class="ttdef"><b>Definition:</b> ParticipantImpl.hpp:71</div></div>
</div><!-- fragment --><p> or via unique_ptr, </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sample = std::make_unique&lt;MyType&gt;();</div>
<div class="line"><span class="comment">/* ... fill out sample here */</span></div>
<div class="line">pub.<a class="code" href="classlt_1_1Publisher.html#aa9a5ba8316bc12616e663feef7531ad3">publish</a>(std::move(sample));</div>
</div><!-- fragment --><p> Publisher erases the <code>MyType</code> information, but publishing a type other than <code>MyType</code> will result in an error. Calling <code>pub.topicType()</code> will return the typename as a string. You can check for subscribers using the Participant, </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> count = node-&gt;subscriberCount(<span class="stringliteral">&quot;my.topic&quot;</span>)</div>
</div><!-- fragment --><p> To stop advertising data, simply dispose of the Publisher object.</p>
<p>Let's Talk also supports differen "Quality of Service" (QoS) settings for publishers and subscribers. An optional string argument to <code>advertise()</code> and <code>subscribe()</code> gives the name of the QoS profile to use. For example, </p><div class="fragment"><div class="line">auto frameQueue = node-&gt;subscribe&lt;VideoFrame&gt;(&quot;video.stream&quot;, &quot;bulk&quot;);</div>
</div><!-- fragment --><p> will set the QoS to the bulk mode. See below for a full description of QoS settings in Let's Talk.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Request/Reply</h2>
<p>In request/reply, a service is defined by a string name, a request type, and a reply type. Let's Talk automatically generates topics for the request and reply from this information. The server side, the one providing the service, registers a callback to perform the service work. Callbacks take the form </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myCallback = [](MyRequestType <span class="keyword">const</span>&amp; i_request) -&gt; MyReplyType { <span class="comment">/* ... */</span> };</div>
</div><!-- fragment --><p> and the registration call on a participant pointer <code>node</code> looks like </p><div class="fragment"><div class="line">node-&gt;advertise&lt;MyRequestType, MyReplyType&gt;(<span class="stringliteral">&quot;my.topic&quot;</span>, myCallback);</div>
</div><!-- fragment --><p> A new thread is spawned for running the callback, so efficiency in the callback is not essential.</p>
<p>To make a request from another participant, first create a Requester object on that node: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> requester = participant-&gt;request&lt;MyRequestType,MyReplyType&gt;(<span class="stringliteral">&quot;my.topic&quot;</span>);</div>
</div><!-- fragment --><p> The requester can be used to make multiple requests. Creating it performs all of the discovery tasks that can be time-consuming. The requester API is straightforward. Making a request returns as <code>std::future</code> of the reply type. You may block waiting on that future immediately, like so </p><div class="fragment"><div class="line">MyRequestType request;</div>
<div class="line"><span class="comment">/* ... fill out request */</span></div>
<div class="line"><span class="keyword">auto</span> reply = requester.request(request).get();</div>
</div><!-- fragment --><p> or wait as much as you can afford and come back to the future later. The requester also has the <code>isConnected()</code> method to check if the server has been found.</p>
<p>Two warnings about request/reply:</p>
<ol type="1">
<li>The service callbacks are allowed to throw exceptions. While the error message isn't propigated to the requester, the <code>std::future</code> will throw a <code>std::runtime_error</code> when <code>get()</code> is called. You should use <code>try/catch</code> if the service you are calling will throw.</li>
<li>Impostor services may exist. Let's Talk does not prevent more than one service provider of the same name from existing or forward requests to exactly one provider. It will however warn you if more than one provider exists for a given service. The Requester has a function call <code>impostorsExist()</code> to check for this state of affairs.</li>
</ol>
<h2><a class="anchor" id="autotoc_md10"></a>
Reactor</h2>
<p>The Reactor uses pull-style API with session objects rather than callbacks. The server-side differs from the request/reply. To provide a reactor service, we first create the server object, </p><div class="fragment"><div class="line">lt::ParticipantPtr node = <a class="code" href="classlt_1_1Participant.html#a266f5f43e44e21fa68f9b7d83899c0e1">lt::Participant::create</a>();</div>
<div class="line"><span class="keyword">auto</span> motionServer = node-&gt;makeReactorServer&lt;RequestType, ReplyType, ProgressType&gt;(<span class="stringliteral">&quot;robot.move&quot;</span>);</div>
</div><!-- fragment --><p> Here, <code>ProgressType</code> is optional; if your service doesn't provide progress data you can omit the argument. <code>ReactorServer</code> objects are lightweight and may be copied cheaply. To see if clients have connected, </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> knownClientCount = motionServer.discoveredClients());</div>
</div><!-- fragment --><p> and to check for pending sessions, </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> pending = motionServer.havePendingSession();</div>
</div><!-- fragment --><p> If this is true, a request has been recieved. To service it, we get a <code>Session</code> object, </p><div class="fragment"><div class="line"><span class="keyword">auto</span> motionSession = motionServer.getPendingSession();</div>
</div><!-- fragment --><p> This takes an optional wait time if you want to have a blocking wait for sessions. Like the server object, this is a lightweight object that may be copied cheaply. Copies all refer to the same logical session. The session object provides accessors for the request data </p><div class="fragment"><div class="line">RequestType <span class="keyword">const</span>&amp; request = motionSession.request();</div>
</div><!-- fragment --><p> We can begin processing the request now. As we go, we can send back progress reports via </p><div class="fragment"><div class="line">ProgressData mySpecialProgress;</div>
<div class="line"><span class="comment">// ... fill out data</span></div>
<div class="line">motionSession.progress(25, mySpecialProgress);</div>
</div><!-- fragment --><p> If you didn't specify a <code>ProgressData</code> type, you may still send progress marks with </p><div class="fragment"><div class="line">motionSession.progress(25);</div>
</div><!-- fragment --><p> The progress mark integer uses values from 1 to 100, with 1 being a special value for "started" and 100 signaling completion. The ReactorServer will automatically send these when you start and finish a session. Note you may send duplicate progress marks, or even have progress decreasing. To signal failure, <code>motionSession.fail()</code> will dispose of the session, notifying the client. To finish a session, </p><div class="fragment"><div class="line">ReplyType reply;</div>
<div class="line"><span class="comment">// ... fill out reply</span></div>
<div class="line">motionSession.reply(reply);</div>
</div><!-- fragment --><p> Additionally, the client may cancel a session at any time. You can check if the session has been cancelled by calling <code>isAlive()</code>.</p>
<p>The client end is similar to the request/reply client. First, we create a client object on the participant: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> motionClient = node-&gt;makeReactorClient&lt;RequestType, ReplyType, ProgressType&gt;(<span class="stringliteral">&quot;robot.motion&quot;</span>);</div>
</div><!-- fragment --><p> We can then check for connections with <code>motionClient.discoveredServer()</code>. Sending a request starts a session </p><div class="fragment"><div class="line">RequestData request;</div>
<div class="line"><span class="comment">// ... fill out request</span></div>
<div class="line"><span class="keyword">auto</span> clientSession = motionClient.request(request);</div>
</div><!-- fragment --><p> The session API provides calls to determine if the session is alive (started by the server), get the current progress, get a progress data sample, or await the final reply. There's also a <code>cancel()</code> call to end the session early.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Examples</h2>
<p>The <code>examples</code> directory contains demonstration programs for these three patterns, as well as sample CMake files. To build the examples, first build and install Let's Talk, then create a symlink to the install directory in the examples directory: </p><div class="fragment"><div class="line">$ cd examples</div>
<div class="line">$ ln -s &lt;lets talk install dir&gt; install</div>
<div class="line">$ mkdir build &amp;&amp; cd build</div>
<div class="line">$ cmake ..</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
Quality of Service (QoS)</h1>
<p>Let's Talk defines three levels of service by default:</p>
<ul>
<li>"reliable" &ndash; the default. This QoS will resend messages when not acknowledged. Publishers will also keep the last published message cached so that late-joining subscribers can be immediately sent the last message on a topic upon discovery.</li>
<li>"bulk" &ndash; Failed sending attempts are not repeated. No queue of old messages is maintained. This is intended for streaming data where it is better to press ahead than dwell upon the past.</li>
<li>"stateful" &ndash; Like reliable, but samples are delivered in-order to the subscriber. This is for topics where samples refer to state provided by previous samples. Note that FastDDS doesn't yet support this, so "stateful" behaves exactly as "reliable" for now.</li>
</ul>
<p>In addition, Participants may have QoS profiles. These are used to alter the underlying protocol from UDP to TCP or something else. Currently only UDP profiles are defined by default.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Using Custom QoS</h2>
<p>If you wish to develop your own QoS profiles, see <a href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/xml_configuration/xml_configuration.html">https://fast-dds.docs.eprosima.com/en/latest/fastdds/xml_configuration/xml_configuration.html</a></p>
<p>When invoking your program, set the enivronment variable <code>LT_PROFILE</code> to the path to your xml. The <code>profile_name</code> attribute may be used as the optional argument for <code>subscribe</code> and <code>advertise</code> to use these QoS settings.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
DDS Concepts in Let's Talk</h1>
<p>The DDS is a publish/subscribe messaging system with automatic discovery. Here's a small primer.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Participant</h2>
<p>Each node in the DDS network is a "participant." Participants discover each other, trading information on available topics and types. Participants also function as factories for the other objects &ndash; topic objects, types, publishers, and subscribers.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Topics</h2>
<p>A topic is a channel for data. It's the combination of a string topic name and a data type. The types generally must be derived from IDL.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Types and IDL</h2>
<p>Types in DDS are typically derived from IDL source. IDL provides a C-like language for describing structured data. The IDL compiler produces C++ source code from these files that includes serialization and deserialization methods to/from the Common Data Format (CDR). DDS automatically performs the required serialization and deserialization as required.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Quality of Service (QoS)</h2>
<p>An overloaded term, QoS refers to all of the run-time settings available in DDS. It includes the network protocol (TCP, UDP, shared memory), the error handling strategy, the depth of message history that is stored, and many other details.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Environment variables</h1>
<p>Let's Talk uses environment variables so that programs can easily modify the behavior at runtime.</p>
<ul>
<li><code>LT_VERBOSE</code> &ndash; enables debug print messages about discovery and message passing</li>
<li><code>LT_LOCAL_ONLY</code> &ndash; If 1, prevents discovery from finding participants on another host</li>
<li><code>LT_PROFILE</code> &ndash; Path to custom QoS profile XML file</li>
</ul>
<p>To use this on you program <code>foo</code>, you can launch foo from the shell like this: </p><div class="fragment"><div class="line">$ LT_VERBOSE=1 ./foo</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
About DDS</h1>
<p>The Data Distribution Service is an efficient and powerful publish/subscribe framework, but it is very complicated. It's worth exploring the chain of acronyms that make it up:</p>
<ul>
<li>DDS &ndash; Data Distribution Service. This isn't a protocol standard at all, it turns out! It's an API standard.</li>
<li>RTPS &ndash; Real-Time Publish Subscribe. This is the protocol standard. It covers how participants discover one another, how topics and types are communicated, how data is sent, and how transmission errors are handled. RTPS uses a peer-to-peer design rather than a central message broker, making it more resillient and flexible. (But also placing larger burdens on those peers.)</li>
<li>IDL &ndash; Interface Description Language. DDS inherited this from the 90's CORBA technology, and the 16/32 bit world of the time defintely shows in the language. IDL is ugly but functional for the purpose. It isn't as fully featured as Google Protocol Buffers, but it is servicable.</li>
<li>CDR &ndash; Common Data Representation. This is the serialized format for data transmitted. Typically, IDL compilers generate native code from IDL that handles serialization to/deserialization from CDR. Compared to Google Protocol Buffers, CDR is faster to serialize/deserialize, but larger on the wire. Given DDS's emphasis on local network communication vs protobuf's focus on internet communication, this makes sense.</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Roadmap</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Future Features</h2>
<ol type="1">
<li>Automate FastDDS version upgrade</li>
<li>To/from json additions for fastddsgen </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
