<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classlt_1_1ActiveObject" kind="class" language="C++" prot="public">
    <compoundname>lt::ActiveObject</compoundname>
    <derivedcompoundref refid="classlt_1_1detail_1_1ServiceProvider" prot="private" virt="non-virtual">lt::detail::ServiceProvider&lt; Req, Rep, C &gt;</derivedcompoundref>
    <includes refid="ActiveObject_8hpp" local="no">ActiveObject.hpp</includes>
      <sectiondef kind="private-type">
      <memberdef kind="typedef" id="classlt_1_1ActiveObject_1a6a0793531984bf6ead951ef47c6fd323" prot="private" static="no">
        <type>std::list&lt; std::function&lt; void()&gt; &gt;</type>
        <definition>using lt::ActiveObject::WorkQueue =  std::list&lt;std::function&lt;void()&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>WorkQueue</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="102" column="5" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="102" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classlt_1_1ActiveObject_1a6291bbb77c8ef55634a4790cf720beab" prot="private" static="no">
        <type>std::unique_lock&lt; std::mutex &gt;</type>
        <definition>using lt::ActiveObject::LockGuard =  std::unique_lock&lt;std::mutex&gt;</definition>
        <argsstring></argsstring>
        <name>LockGuard</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="103" column="5" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="103" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classlt_1_1ActiveObject_1a39e9e3bfe540964cf8ec91c7438bd842" prot="private" static="no" mutable="no">
        <type>WorkQueue</type>
        <definition>WorkQueue lt::ActiveObject::m_work</definition>
        <argsstring></argsstring>
        <name>m_work</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="105" column="15" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="105" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classlt_1_1ActiveObject_1a7b232c80ddf46fbe6d3409ed816995c5" prot="private" static="no" mutable="yes">
        <type>std::mutex</type>
        <definition>std::mutex lt::ActiveObject::m_mutex</definition>
        <argsstring></argsstring>
        <name>m_mutex</name>
        <briefdescription>
<para>Queue of pending functions, guarded by m_mutex. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="106" column="24" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="106" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classlt_1_1ActiveObject_1ab2590e10a273b6dcb40040d5867805b1" prot="private" static="no" mutable="no">
        <type>std::thread</type>
        <definition>std::thread lt::ActiveObject::m_workThread</definition>
        <argsstring></argsstring>
        <name>m_workThread</name>
        <briefdescription>
<para>Guards work queue. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="107" column="17" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="107" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classlt_1_1ActiveObject_1af8f090958bf279064b7e92cbd8d06232" prot="private" static="no" mutable="no">
        <type>std::atomic_bool</type>
        <definition>std::atomic_bool lt::ActiveObject::m_keepAlive</definition>
        <argsstring></argsstring>
        <name>m_keepAlive</name>
        <briefdescription>
<para>Private thread for running work items. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="108" column="22" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="108" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classlt_1_1ActiveObject_1acae649388259b0abae128c62c726d9ab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>lt::ActiveObject::ActiveObject</definition>
        <argsstring>()</argsstring>
        <name>ActiveObject</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Starts the work thread </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="66" column="5" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="66" bodyend="66"/>
      </memberdef>
      <memberdef kind="function" id="classlt_1_1ActiveObject_1abcd7484dd35a1818c9a111ce8864cb8a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type></type>
        <definition>virtual lt::ActiveObject::~ActiveObject</definition>
        <argsstring>()</argsstring>
        <name>~ActiveObject</name>
        <briefdescription>
<para>Stops the work thread and finishes any pending jobs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="71" column="13" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="71" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="classlt_1_1ActiveObject_1ac19473739c6a7285bfa55ac546b68a82" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool lt::ActiveObject::isWorking</definition>
        <argsstring>() const</argsstring>
        <name>isWorking</name>
        <briefdescription>
<para>Checks if the work thread is running. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="76" column="10" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="76" bodyend="76"/>
      </memberdef>
      <memberdef kind="function" id="classlt_1_1ActiveObject_1a5b85dbd06cb6982b7d5b4fe56b33293e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void lt::ActiveObject::startWork</definition>
        <argsstring>()</argsstring>
        <name>startWork</name>
        <briefdescription>
<para>Starts the work thread if it is not already started. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="81" column="10" bodyfile="/home/mike/git/letstalk/src/ActiveObject.cpp" bodystart="8" bodyend="32"/>
      </memberdef>
      <memberdef kind="function" id="classlt_1_1ActiveObject_1a1363a0c730f8b90a7b58ebbd53ee382c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void lt::ActiveObject::stopWork</definition>
        <argsstring>()</argsstring>
        <name>stopWork</name>
        <briefdescription>
<para>Stops the work thread if it is running, finishing any pending jobs on the caller&apos;s thread. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="87" column="10" bodyfile="/home/mike/git/letstalk/src/ActiveObject.cpp" bodystart="34" bodyend="38"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classlt_1_1ActiveObject_1a5b075a371f534413a9066ce66ff4c0f8" prot="protected" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void lt::ActiveObject::submitJob</definition>
        <argsstring>(C i_job)</argsstring>
        <name>submitJob</name>
        <param>
          <type>C</type>
          <declname>i_job</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Submit a job. C must be copyable (a lambda is typical) with no function arguments. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="95" column="10" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="95" bodyend="99"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A class with an internal worker thread to synchronize access to private members. </para>
    </briefdescription>
    <detaileddescription>
<para><ref refid="classlt_1_1ActiveObject" kindref="compound">ActiveObject</ref> is a virtual base class for the active object pattern. This creates a private thread with an internal queue of jobs. The jobs are run one at a time in order of insertion into the queue.</para>
<para>A typical pattern looks like <programlisting><codeline><highlight class="normal">class<sp/>Counter<sp/>:<sp/>public<sp/>ActiveObject</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Counter()<sp/>:<sp/>m_count(0)<sp/>{<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>add(int<sp/>i_amount)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>submitJob([i_amount,<sp/>this]()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>m_count<sp/>+=<sp/>i_amount;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">std::future&lt;int&gt;<sp/>value()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>//<sp/>Note:<sp/>we<sp/>must<sp/>handle<sp/>the<sp/>promise<sp/>via<sp/>a<sp/>pointer<sp/>to<sp/>caputre<sp/>it<sp/>correctly.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>auto<sp/>promise<sp/>=<sp/>std::make_shared&lt;std::promise&lt;int&gt;&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>submitJob([promise,<sp/>this]()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>promise-&gt;set_value(m_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return<sp/>promise-&gt;get_future();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">protected:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>m_count;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Notice that no explicit mutex is required to protect m_count. Calls to add() and value() from different threads will occur in race order, but only one will be executed at a time.</para>
<para>By convention, the private members of an active object run on the private thread. That is, they are used by lambdas defined inside of <ref refid="classlt_1_1ActiveObject_1a5b075a371f534413a9066ce66ff4c0f8" kindref="member">submitJob()</ref>. This allows the object to be programmed as if it were not thread safe for its interior business logic. Return values must all be done via std::future. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>lt::ActiveObject</label>
        <link refid="classlt_1_1ActiveObject"/>
      </node>
      <node id="2">
        <label>lt::detail::ServiceProvider&lt; Req, Rep, C &gt;</label>
        <childnode refid="1" relation="private-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="/home/mike/git/letstalk/src/ActiveObject.hpp" line="61" column="1" bodyfile="/home/mike/git/letstalk/src/ActiveObject.hpp" bodystart="61" bodyend="109"/>
    <listofallmembers>
      <member refid="classlt_1_1ActiveObject_1acae649388259b0abae128c62c726d9ab" prot="public" virt="non-virtual"><scope>lt::ActiveObject</scope><name>ActiveObject</name></member>
      <member refid="classlt_1_1ActiveObject_1ac19473739c6a7285bfa55ac546b68a82" prot="public" virt="non-virtual"><scope>lt::ActiveObject</scope><name>isWorking</name></member>
      <member refid="classlt_1_1ActiveObject_1a6291bbb77c8ef55634a4790cf720beab" prot="private" virt="non-virtual"><scope>lt::ActiveObject</scope><name>LockGuard</name></member>
      <member refid="classlt_1_1ActiveObject_1af8f090958bf279064b7e92cbd8d06232" prot="private" virt="non-virtual"><scope>lt::ActiveObject</scope><name>m_keepAlive</name></member>
      <member refid="classlt_1_1ActiveObject_1a7b232c80ddf46fbe6d3409ed816995c5" prot="private" virt="non-virtual"><scope>lt::ActiveObject</scope><name>m_mutex</name></member>
      <member refid="classlt_1_1ActiveObject_1a39e9e3bfe540964cf8ec91c7438bd842" prot="private" virt="non-virtual"><scope>lt::ActiveObject</scope><name>m_work</name></member>
      <member refid="classlt_1_1ActiveObject_1ab2590e10a273b6dcb40040d5867805b1" prot="private" virt="non-virtual"><scope>lt::ActiveObject</scope><name>m_workThread</name></member>
      <member refid="classlt_1_1ActiveObject_1a5b85dbd06cb6982b7d5b4fe56b33293e" prot="public" virt="non-virtual"><scope>lt::ActiveObject</scope><name>startWork</name></member>
      <member refid="classlt_1_1ActiveObject_1a1363a0c730f8b90a7b58ebbd53ee382c" prot="public" virt="non-virtual"><scope>lt::ActiveObject</scope><name>stopWork</name></member>
      <member refid="classlt_1_1ActiveObject_1a5b075a371f534413a9066ce66ff4c0f8" prot="protected" virt="non-virtual"><scope>lt::ActiveObject</scope><name>submitJob</name></member>
      <member refid="classlt_1_1ActiveObject_1a6a0793531984bf6ead951ef47c6fd323" prot="private" virt="non-virtual"><scope>lt::ActiveObject</scope><name>WorkQueue</name></member>
      <member refid="classlt_1_1ActiveObject_1abcd7484dd35a1818c9a111ce8864cb8a" prot="public" virt="virtual"><scope>lt::ActiveObject</scope><name>~ActiveObject</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
